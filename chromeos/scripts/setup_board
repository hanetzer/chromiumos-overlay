#!/bin/bash

# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This script sets up a the sysroot for a particular target board.

# Load common constants.  This should be the first executable line.
# The path to common.sh should be relative to your script's location.
. "$(dirname "$0")/common.sh"

# Script must be run inside the chroot
restart_in_chroot_if_needed $*

get_default_board

# Flags
DEFINE_string board "$DEFAULT_BOARD" \
  "The name of the board to set up."
DEFINE_string build_root "/build" \
  "The root location for board sysroots."
DEFINE_string board_overlay "" \
  "Location of the board overlay."
DEFINE_string variant "" \
  "Board variant."
DEFINE_string toolchain "" \
  "Toolchain.  For example: i686-pc-linux-gnu, armv7a-softfloat-linux-gnueabi"
DEFINE_boolean usepkg $FLAGS_TRUE \
  "Use binary packages to bootstrap."
DEFINE_boolean force $FLAGS_FALSE \
  "Force re-creating board root."
DEFINE_string binutils_version "" \
  "Version of binutils to use."
DEFINE_string gcc_version "" \
  "Version of gcc to use."
DEFINE_string libc_version "2.10.1-r2" \
  "Version of libc to use."
DEFINE_string kernel_version "2.6.30-r1" \
  "Version of kernel headers to use."
DEFINE_boolean default $FLAGS_FALSE \
  "Set board to the default board in your chroot"
DEFINE_boolean fast ${DEFAULT_FAST} "Call many emerges in parallel"
DEFINE_string profile "" \
  "The portage configuration profile to use. Profile must be located in overlay-board/profiles"


tc_pkg_needs_update() {
  CURRENT_VERSION=$(equery l cross-${FLAGS_toolchain}/* | grep $1 | \
    cut -d '/' -f 2 | cut -d '-' -f 2-)
  eval NEW_VERSION="\${FLAGS_${1}_version}"
  if [ "${CURRENT_VERSION}" == "${NEW_VERSION}" ]; then
    echo ${FLAGS_FALSE}
  else
    echo ${FLAGS_TRUE}
  fi
}

uninstall_toolchain() {
  echo "Uninstalling the toolchain."
  # Even if the uninstall fails, keep going. It's likely
  # that it didn't exist in the first place.
  sudo crossdev -v -C $FLAGS_toolchain || true
}

# Build the toolchain with crossdev.
build_toolchain() {
  echo "Building the toolchain."
  # TODO(davidjames): Fix uploading of cross prebuilts so that we don't have
  #                   to use the old location to get the cross prebuilts.
  #BINHOST=$(portageq envvar PORTAGE_BINHOST)
  BINHOST="http://gsdview.appspot.com/chromeos-prebuilt/host/amd64/15.12.10.153419/packages/"
  CROSS_BINHOST="${BINHOST}cross/$FLAGS_toolchain/"
  CROSS_USEPKG=""
  if [ $FLAGS_usepkg -eq $FLAGS_TRUE ]; then
    # Grab the latest packages from the prebuilt server.
    #  -G: Use packages from the prebuilt server. Don't build from source.
    #  --binpkg-respect-use=n: Don't discard binary packages due to use flags.
    #  --usepkg=n: Don't use local binary packages.
    #  --without-headers: Don't build headers-only versions of packages for
    #                     bootstrapping. Because we use binary packages, this
    #                     isn't necessary.
    CROSS_USEPKG="--portage -G --portage --binpkg-respect-use=n"
    CROSS_USEPKG="${CROSS_USEPKG} --portage --usepkg=n --without-headers"
  fi

  CROSS_BINUTILS="--binutils $FLAGS_binutils_version"
  CROSS_GCC="--gcc $FLAGS_gcc_version"
  CROSS_KERNEL="--kernel $FLAGS_kernel_version"
  CROSS_LIBC="--libc $FLAGS_libc_version"
  sudo PORTAGE_BINHOST="${CROSS_BINHOST}" crossdev -v \
      --target "$FLAGS_toolchain" \
      $CROSS_BINUTILS \
      $CROSS_GCC      \
      $CROSS_KERNEL   \
      $CROSS_LIBC     \
      $CROSS_USEPKG

  # Set up toolchain wrappers to force $SYSROOT and perform sanity checks.
  GCC_PROFILE="${FLAGS_toolchain}-${GCC_VERSION}"
  GCC_BIN_PATH=$(gcc-config --get-bin-path "$GCC_PROFILE")
  CCACHE_BIN=$(which ccache || true)
  for i in c++ cpp g++ gcc gfortran ; do
    GCC_BINARY="${GCC_BIN_PATH}/$FLAGS_toolchain-${i}"
    if [ ! -L "${GCC_BINARY}" ] ; then
      sudo mv "${GCC_BINARY}" "${GCC_BINARY}.real"
      sudo ln -s "${SCRIPTS_DIR}/sysroot_wrapper" "${GCC_BINARY}"
    fi
    if [ -f "${CCACHE_BIN}" ]; then
      sudo ln -sf "${CCACHE_BIN}" "/usr/lib/ccache/bin/${FLAGS_toolchain}-${i}"
    fi
  done
}

# Install all of the stuff that depends on the toolchain versions
# into the board root.
install_toolchain_in_board() {
  echo "Installing the toolchain into the board root."
  #
  # Untar glibc to get most of the headers required to build.
  #
  PKGDIR=$(portageq envvar PKGDIR)
  sudo tar jxpf \
  "${PKGDIR}/cross/${FLAGS_toolchain}/cross-${FLAGS_toolchain}"/glibc-${FLAGS_libc_version}.tbz2 \
      -C "${BOARD_ROOT}" --strip-components=3

  # Symlink for libstdc++.la issues. It appears that when packages get merged
  # the .la files will be updated, and for libstdc++ it will use the wrong
  # location. This works around that issue.
  sudo ln -sf /usr/lib64/gcc "${BOARD_ROOT}/usr/lib/gcc"

  # We need to install libstdc++ manually from the cross toolchain.
  # TODO: Figure out a better way of doing this?
  sudo cp -a /usr/lib/gcc/"${FLAGS_toolchain}"/"${GCC_VERSION}"/libgcc_s.so* "${BOARD_ROOT}/lib"
  sudo cp -a /usr/lib/gcc/"${FLAGS_toolchain}"/"${GCC_VERSION}"/libstdc++.so* \
      "${BOARD_ROOT}/usr/lib"

  # Some header files are needed also for rpcbind (NFS support)
  # TODO: Figure out a better way of doing this too?
  sudo cp -a /usr/include/rpcsvc/mount.h "${BOARD_ROOT}/usr/include/rpcsvc"
  sudo cp -a /usr/include/rpcsvc/rquota.h "${BOARD_ROOT}/usr/include/rpcsvc"
  sudo cp -a /usr/include/rpcsvc/nfs_prot.h "${BOARD_ROOT}/usr/include/rpcsvc"
  sudo cp -a /usr/include/rpcsvc/yppasswd.h "${BOARD_ROOT}/usr/include/rpcsvc"

  # Tell portage that toolchain packages are already installed in the sysroot.
  PROVIDED="${BOARD_PROFILE}/package.provided"
  sudo sh -c \
      "echo \"sys-devel/binutils-${FLAGS_binutils_version}\" >> \"${PROVIDED}\""
  sudo sh -c "echo \"sys-devel/gcc-${FLAGS_gcc_version}\" >> \"${PROVIDED}\""
  sudo sh -c "echo \"sys-libs/glibc-${FLAGS_libc_version}\" >> \"${PROVIDED}\""
}

# Parse command line flags
FLAGS "$@" || exit 1
eval set -- "${FLAGS_ARGV}"

# Only now can we die on error.  shflags functions leak non-zero error codes,
# so will die prematurely if 'set -e' is specified before now.
set -e

if [ -z "$FLAGS_board" ] ; then
  error "--board required."
  exit 1
fi

#
# Before we can run any tools, we need to emerge hard-host-depends.
#
EMERGE_CMD="emerge"
if [ "$FLAGS_fast" -eq "${FLAGS_TRUE}" ]; then
  EMERGE_CMD="${SCRIPTS_DIR}/parallel_emerge"
fi
sudo -E ${EMERGE_CMD} -uDNvg chromeos-base/hard-host-depends world

get_board_and_variant $FLAGS_board $FLAGS_variant

#
# Construct board overlay list.
#
BOARD_OVERLAY_LIST=$($SCRIPTS_DIR/bin/cros_overlay_list \
  --board "$BOARD" \
  --board_overlay "$FLAGS_board_overlay" \
  --variant "$VARIANT")

#
# Populate the BOARD_MAKE_CONF_LIST with any make.conf files found in the
# overlays.
#
BOARD_MAKE_CONF_LIST=""

for overlay in ${BOARD_OVERLAY_LIST} ; do
  if [ -f "${overlay}/make.conf" ]; then
    BOARD_MAKE_CONF_LIST="${BOARD_MAKE_CONF_LIST} ${overlay}/make.conf"
  fi
done

#
# Check if there are any board overlays.  There should be at least a top
# level board specific overlay.
#
PRIMARY_BOARD_OVERLAY=$($SCRIPTS_DIR/bin/cros_overlay_list \
  --board "$BOARD" \
  --primary_only)

#
# Fetch the toolchain from the board overlay.
#
BOARD_TOOL_CHAIN="${PRIMARY_BOARD_OVERLAY}/toolchain.conf"
FLAGS_toolchain=${FLAGS_toolchain:-$(cat ${BOARD_TOOL_CHAIN})}

# Figure out ARCH from the given toolchain
# TODO: Move to common.sh as a function after scripts are switched over.
if [ -z "${FLAGS_toolchain}" ]; then
  error "No toolchain specified in board overlay or on command line."
  exit 1
fi

TC_ARCH=$(echo "$FLAGS_toolchain" | awk -F'-' '{ print $1 }')
case "$TC_ARCH" in
  arm*)
    ARCH="arm"
    ;;
  *86)
    ARCH="x86"
    ;;
  *)
    error "Unable to determine ARCH from toolchain: $FLAGS_toolcahin"
    exit 1
esac

# Toolchain defaults
# binutils-2.19.1-r1 is upstream r1, binutils-2.20.1-r3 is crosstool
if [ -z $FLAGS_binutils_version ]; then
  if [ "$ARCH" == "x86" ]; then
    FLAGS_binutils_version="2.20.1-r3"
  else
    FLAGS_binutils_version="2.19.1-r1"
  fi
fi

# gcc-4.4.3-r4 is upstream r4. gcc-4.4.3-r5 is crosstoolv14.
if [ -z $FLAGS_gcc_version ]; then
  if [ "$ARCH" == "x86" ]; then
    FLAGS_gcc_version="4.4.3-r5"
  else
    FLAGS_gcc_version="4.4.3-r4"
  fi
fi

# Locations we will need
BOARD_ROOT="${FLAGS_build_root}/${BOARD_VARIANT}"
CHROMIUMOS_OVERLAY="/usr/local/portage/chromiumos/"
CHROMIUMOS_CONFIG="${CHROMIUMOS_OVERLAY}/chromeos/config"
CHROMIUMOS_PROFILES="${CHROMIUMOS_OVERLAY}/profiles"
BOARD_ETC="${BOARD_ROOT}/etc"
BOARD_PROFILE="${BOARD_ETC}/portage/profile"

# Version of GCC we will be installing, without the ebuild revision number.
GCC_VERSION=`echo ${FLAGS_gcc_version} | sed -e 's/\-r[0-9]*$//g'`

if [ "$(tc_pkg_needs_update "binutils")" = "$FLAGS_TRUE" ] ||
  [ "$(tc_pkg_needs_update "gcc")" = "$FLAGS_TRUE" ] ||
  [ "$(tc_pkg_needs_update "libc")" = "$FLAGS_TRUE" ]; then
  warn "Toolchain needs to be updated! Updating toolchain..."
  uninstall_toolchain
  build_toolchain
  # If the board root already exists, re-install the toolchain there.
  if [ -d "$BOARD_ROOT" ] && [ "$FLAGS_force" = "$FLAGS_FALSE" ]; then
    install_toolchain_in_board
  fi
fi

if [ -d "$BOARD_ROOT" ] ; then
  if [[ $FLAGS_force -eq $FLAGS_TRUE ]]; then
    echo "--force set.  Re-creating $BOARD_ROOT..."
    # Removal takes long. Make it asynchronous.
    TEMP_DIR=`mktemp -d`
    sudo mv $BOARD_ROOT $TEMP_DIR
    sudo rm -rf $TEMP_DIR &
  else
    warn "Board output directory '$BOARD_ROOT' already exists."
    warn "Not setting up board root. "
    warn "Use --force to clobber the board root and start again."
    exit 1
  fi
fi

sudo mkdir -p "$BOARD_ROOT"

# TODO(cmasone): Do this more cleanly, if we figure out what "cleanly" means.
# Set up wrapper for pkg-config.  Point a board-specific wrapper at the
# generic wrapper script created by crossdev-wrapper
sudo ln -sf "/usr/bin/cross-pkg-config" "/usr/bin/${FLAGS_toolchain}-pkg-config"

# Setup make.conf and make.profile as symlinks to ones in revision control
sudo mkdir -p "${BOARD_ETC}" "${BOARD_PROFILE}"

# Start with the crossdev etc
# TODO(tedbo): The sed lines are hacks to fix an issue where the crossdev
# wrapper wants to assume that SYSROOT is /usr/${CHOST}. We should fix this
# in the crossdev code and try to upstream.
sudo cp -a /usr/share/crossdev/etc/* "${BOARD_ETC}"
sudo sed -i 's/${CHOST}/${SYSROOT}/g' "${BOARD_ETC}/portage/bashrc"
sudo sed -i 's/CROSS_ROOT=""/CROSS_ROOT="$1"/g' /usr/bin/cross-fix-root

# Setup the make.confs. We use the following:
#    make.conf             <- Overall target make.conf [arm, x86, etc. version]
#    make.conf.board_setup <- Declares CHOST, ROOT, etc.
#    make.conf.common      <- Common settings across all targets
#    make.conf.board       <- Optional board-supplied make.conf
sudo ln -sf "${CHROMIUMOS_CONFIG}/make.conf.${ARCH}-target" \
  "${BOARD_ETC}/make.conf"
sudo ln -sf "${CHROMIUMOS_CONFIG}/make.conf.common-target" \
  "${BOARD_ETC}/make.conf.common"
cat <<EOF | sudo dd of="${BOARD_ETC}/make.conf.board_setup" > /dev/null 2>&1
# Created by setup_board
CHOST="${FLAGS_toolchain}"
ROOT="${BOARD_ROOT}/"
BOARD_OVERLAY="${BOARD_OVERLAY_LIST}"
MAKEOPTS="-j${NUM_JOBS}"
LIBC_VERSION="$FLAGS_libc_version"
EOF

# We install the toolchain related bits after the BOARD_ROOT, BOARD_PROFILE
# and BOARD_ETC directories have been created.
install_toolchain_in_board

sudo touch "${BOARD_ETC}/make.conf.board"

for make_conf in ${BOARD_MAKE_CONF_LIST} ; do
  sudo bash -c "echo source ${make_conf} >> ${BOARD_ETC}/make.conf.board"
done

# Setup make.globals and the profile.
sudo touch /etc/make.conf.user
sudo ln -sf /etc/make.globals "${BOARD_ROOT}/etc/make.globals"
sudo ln -sf /etc/make.conf.user "${BOARD_ROOT}/etc/make.conf.user"
sudo rm "${BOARD_ROOT}/etc/make.profile"
# The profile directory comes from four possible locations:
#  * relative profile name from --profile in overlay-board/profiles/<name>
#  * absolute profile path from --profile
#  * overlay-board/profiles/base
#  * ${CHROMIUMOS_PROFILES}/default/linux/${ARCH}/10.0/chromeos
# If --profile is non-null and does not exist the script will error
# If none of the directories exist the script will error as well
PORTAGE_PROFILES_DIR=""
if [ ! -z "${FLAGS_profile}" ]; then  # profile specified. must exist or we fail
    if [ -d "${PRIMARY_BOARD_OVERLAY}/profiles/${FLAGS_profile}" ]; then
	PORTAGE_PROFILES_DIR="${PRIMARY_BOARD_OVERLAY}/profiles/${FLAGS_profile}"
    elif [ -d "${FLAGS_profile}" ]; then
	PORTAGE_PROFILES_DIR="${FLAGS_profile}"
    fi
    if [ -z "${PORTAGE_PROFILES_DIR}" ]; then
	error "Profile argument passed as '${FLAGS_profile}' but it does not exist"
	exit 1
    fi
elif [ -d "${PRIMARY_BOARD_OVERLAY}/profiles/base" ]; then
    PORTAGE_PROFILES_DIR="${PRIMARY_BOARD_OVERLAY}/profiles/base/"
else
    PORTAGE_PROFILES_DIR="${CHROMIUMOS_PROFILES}/default/linux/${ARCH}/10.0/chromeos/"
fi
if [ -z "${PORTAGE_PROFILES_DIR}" ]; then
    error "Profiles directory not found"
    exit 1
fi
sudo ln -sf "${PORTAGE_PROFILES_DIR}" "${BOARD_ROOT}/etc/make.profile"
if [ ! -f "${PORTAGE_PROFILES_DIR}/parent" ]; then
    warn "Portage profile directory '${PORTAGE_PROFILES_DIR}' has no file 'parent'.  This likely means your profile directory is invalid and build_packages will fail"
fi

# Create emerge wrapper
EMERGE_WRAPPER="/usr/local/bin/emerge-${BOARD_VARIANT}"
EBUILD_WRAPPER="/usr/local/bin/ebuild-${BOARD_VARIANT}"
ECLEAN_WRAPPER="/usr/local/bin/eclean-${BOARD_VARIANT}"
EQUERY_WRAPPER="/usr/local/bin/equery-${BOARD_VARIANT}"
PORTAGEQ_WRAPPER="/usr/local/bin/portageq-${BOARD_VARIANT}"
CROS_WORKON_WRAPPER="/usr/local/bin/cros_workon-${BOARD_VARIANT}"
cat <<EOF | sudo dd of="$EMERGE_WRAPPER" > /dev/null 2>&1
#!/bin/bash

export CHROMEOS_ROOT="$GCLIENT_ROOT"
export CHOST="$FLAGS_toolchain"
export PORTAGE_CONFIGROOT="$BOARD_ROOT"
export SYSROOT="$BOARD_ROOT"
if [ -z "\$PORTAGE_USERNAME" ]; then
  export PORTAGE_USERNAME=\$(basename \$HOME)
fi
EOF

sudo chmod +x "$EMERGE_WRAPPER"
sudo cp "$EMERGE_WRAPPER" "$EBUILD_WRAPPER"
sudo cp "$EMERGE_WRAPPER" "$ECLEAN_WRAPPER"
sudo cp "$EMERGE_WRAPPER" "$EQUERY_WRAPPER"
sudo cp "$EMERGE_WRAPPER" "$PORTAGEQ_WRAPPER"

cat <<EOF | sudo dd of="$EMERGE_WRAPPER" \
        oflag=append conv=notrunc > /dev/null 2>&1
exec sudo -E emerge --root-deps "\$@"
EOF

cat <<EOF | sudo dd of="$EBUILD_WRAPPER" \
        oflag=append conv=notrunc > /dev/null 2>&1
export ROOT="$BOARD_ROOT"
exec sudo -E ebuild "\$@"
EOF

cat <<EOF | sudo dd of="$ECLEAN_WRAPPER" \
        oflag=append conv=notrunc > /dev/null 2>&1
export ROOT="$BOARD_ROOT"
exec sudo -E eclean "\$@"
EOF

cat <<EOF | sudo dd of="$EQUERY_WRAPPER" \
        oflag=append conv=notrunc > /dev/null 2>&1
export ROOT="$BOARD_ROOT"
exec sudo -E equery "\$@"
EOF

cat <<EOF | sudo dd of="$PORTAGEQ_WRAPPER" \
        oflag=append conv=notrunc > /dev/null 2>&1
export ROOT="$BOARD_ROOT"
exec sudo -E portageq "\$@"
EOF

cat <<EOF | sudo dd of="$CROS_WORKON_WRAPPER" > /dev/null 2>&1
#!/bin/bash
exec ${SCRIPTS_DIR}/cros_workon --board ${BOARD_VARIANT} "\$@"
EOF

sudo chmod +x "$CROS_WORKON_WRAPPER"

#
# Emerge the kernel headers into the board build root.
#
EMERGE_FLAGS=""
if [[ $FLAGS_usepkg -eq $FLAGS_TRUE ]]; then
  EMERGE_FLAGS="${EMERGE_FLAGS} --getbinpkg --usepkg"
fi
sudo "${EMERGE_WRAPPER}" $EMERGE_FLAGS chromeos-base/kernel-headers

# Temporary hack needed so that we can move headers install back into
# the kernel-headers ebuild.
# TODO(msb): Remove this hack.
sudo chown -Rf ${USER} ~/trunk/.config || true
mkdir -p ~/trunk/.config/headers-fix
touch ~/trunk/.config/headers-fix/"${FLAGS_board}"

if [ $FLAGS_default -eq $FLAGS_TRUE ] ; then
  echo $BOARD_VARIANT > "$GCLIENT_ROOT/src/scripts/.default_board"
fi

echo "Done!"
echo "You can use the following wrappers:"
echo "  ${EMERGE_WRAPPER}"
echo "  ${EBUILD_WRAPPER}"
echo "  ${EQUERY_WRAPPER}"
echo "  ${PORTAGEQ_WRAPPER}"
echo "  ${CROS_WORKON_WRAPPER}"
echo "The SYSROOT is: ${BOARD_ROOT}"
